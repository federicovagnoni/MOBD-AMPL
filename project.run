reset;
model project.mod;

param lbx{1..24};
param ubx{1..24};

data project.dat;
display "ciao";

#best 1522932968287072 0.034581
#best 304586335471 0.034375
#best 304586421275 0.0341056
option randseed 1523177691204678;

param lb;
param ub;
param lb_f;
param ub_f;
param mean;
param std;

let lb_f := 0;
let ub_f := 20;


# Read and scale
include readandscale.run;

/*
for {i in 22..24} {
	let{p in 1..ptr} xtr2[i-21,p] := xtr[i,p];
}

for {i in 22..24} {
	let{p in 1..pval} xval2[i-21,p] := xval[i,p];
}

for {i in 22..24} {
	let{p in 1..ptest} xtest2[i-21,p] := xtest[i,p];
}
*/


# Start training
let err_tr := 1.e30;
let err_val := 1.e30;
#let err_tst := 1.e30;


repeat while (stop_tr == 0){
	
	let loc_err_tr := 1.e30;
	let loc_err_val := 1.e30;
	#let loc_err_tst:=1.e30;
	
	#multistart for nl neurons in the hidden layer
	for {k in 1..nmax} {
				
		#let{i in 1..nl} w[i] := Uniform(-100,100);	
		#let{i in 1..n-1, j in 1..nl} c[i,j] := Uniform(-100,100);
		let{i in 1..nl} v[i] := Uniform(rangeinf,rangesup);
		let{z in 1..n, j in 1..nl} win[z,j] := Uniform(rangeinf,rangesup);		
		
		option solver knitro;
		option knitro_options "opttol = 0.001";
		option solver_msg 0;
		solve;
		
		#saving best error on the validation set for nl neurons
		if (error_val <= loc_err_val) then { 
			printf "error on validation improved: old %f new %f\n", loc_err_val, error_val;
			let loc_err_val := error_val;
			let loc_err_tr := error_tr;
			#let loc_err_tst:= error_test;

		}
		let best_k_loc := k;
	} 

	#check for a global improvement on the validation set
	if (loc_err_val < err_val) then {
	#updating the best error and increasing the number of neurons
		printf "the best error on the validation set is %f with %d neurons \n",
			loc_err_val,nl;
		let best_nl := nl; 
		let best_k := best_k_loc;
		let nl := nl+1;
		let err_val := loc_err_val;
		let err_tr := loc_err_tr;
		#let err_tst := loc_err_tst;

	}
	else 
	#stop
		let stop_tr := 1;
}#while

display best_nl;
display err_tr;
display err_val;
#printf "final error on the test set is %f\n", err_tst;

param value{1..pval};

for {p in 1..pval} {
	let value[p] := sum{j in 1..nl}(v[j]/(1 + exp(- c * (sum{k in 1..n-1} win[k,j]*xval[k,p] - win[n,j]))));
	let value[p] := value[p] * (ub_f - lb_f) + lb_f;
	#display value[p];
}



